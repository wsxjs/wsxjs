{
  "documents": [
    {
      "id": "guide/WSX_DESIGN",
      "title": "WSX_DESIGN",
      "category": "guide",
      "route": "/docs/guide/WSX_DESIGN",
      "content": "WSXJS 设计说明文档\n\n 一、框架简介\nWSXJS 是一套现代 Web Components 框架，主打 JSX 语法与 TypeScript 支持，完全零依赖 React，专注于原生 WebComponent 能力的极致开发体验。\n\n- 核心理念：WebComponent + JSX + TypeScript，极致类型安全与开发效率。\n- wsx 文件：即 Web Component with JSX，采用 .wsx 扩展名，等价于 TSX 语法的 WebComponent。\n- 自举验证：examples 目录即为 wsx 体系自举与验证的主场景。\n\n 二、项目结构\n- packages/core：核心能力（WebComponent 抽象基类、JSX 工厂、自动注册、样式管理、日志等）\n- packages/vite-plugin：Vite 插件，自动处理 .wsx 文件、JSX 工厂注入、TypeScript 编译、热更新\n- packages/eslint-plugin：专用 ESLint 规则（render-method-required、no-react-imports"
    },
    {
      "id": "guide/WEB_COMPONENT_GUIDE",
      "title": "WEB_COMPONENT_GUIDE",
      "category": "guide",
      "route": "/docs/guide/WEB_COMPONENT_GUIDE",
      "content": "WebComponent 使用指南\n\n 概述\n\nWebComponent 是 WSXJS 提供的标准自定义元素基类，使用 Shadow DOM 提供完全的样式隔离和封装。它是构建可复用 UI 组件的首选，特别适合需要样式隔离和完全封装的场景。\n\n 为什么使用 WebComponent？\n\n 适用场景\n\n1. 可复用 UI 组件\n   - 按钮、输入框、卡片等通用组件\n   - 需要完全样式隔离的组件\n   - 组件库开发\n\n2. 样式隔离需求\n   - 避免样式冲突\n   - 需要完全封装的组件\n   - 组件样式不应影响外部\n\n3. 焦点保持功能\n   - 表单输入组件\n   - 需要保持用户输入焦点的场景\n   - 动态内容更新时保持交互状态\n\n4. 完全封装\n   - 组件内部实现细节需要隐藏\n   - 防止外部样式和脚本干扰\n   - 提供稳定的组件 API\n\n 不适用场景\n\n- 需要与第三方库集成（EditorJS、Chart.js 等）→ 使用 LightComponent\n- 需要全局 DOM 访问 → 使用 LightComponent\n- 需要事件自然冒泡到文档级别 "
    },
    {
      "id": "guide/TYPESCRIPT_WSX_TYPES",
      "title": "TYPESCRIPT_WSX_TYPES",
      "category": "guide",
      "route": "/docs/guide/TYPESCRIPT_WSX_TYPES",
      "content": "WSX 类型系统指南\n\n本指南详细说明了 WSXJS 中 .wsx 文件类型系统的工作原理、维护方式和最佳实践。\n\n 目录\n\n- 为什么每个包都需要 wsx.d.ts？为什么每个包都需要-wsxdts\n- 如何维护类型一致性？如何维护类型一致性\n- 开发者指南开发者指南\n- 故障排查故障排查\n\n---\n\n 为什么每个包都需要 wsx.d.ts？\n\n 问题背景\n\n在 WSXJS 的 monorepo 结构中，多个包（wsx-router、base-components、examples 等）都包含了相同的 wsx.d.ts 文件，这看起来是重复的。但这是必需的，而不是设计失误。\n\n TypeScript 模块类型声明的限制\n\n关键概念：declare module \".wsx\" 属于 模块模式声明（Pattern Ambient Module）。\n\nTypeScript 的类型解析机制要求：\n- 模块模式声明必须存在于编译上下文中\n- 无法从 nodemodules 自动传播\n- compilerOptions.types 字段只影响全局类型（如 @types/node），不影响模块模式"
    },
    {
      "id": "guide/TYPESCRIPT_SETUP",
      "title": "TYPESCRIPT_SETUP",
      "category": "guide",
      "route": "/docs/guide/TYPESCRIPT_SETUP",
      "content": "TypeScript 配置指南\n\n本指南详细说明如何在项目中正确配置 TypeScript 以使用 WSXJS。\n\n 📋 目录\n\n- 基本配置基本配置\n- 完整配置示例完整配置示例\n- 类型引用机制类型引用机制\n- 最佳实践最佳实践\n- 常见问题常见问题\n\n 基本配置\n\n 1. JSX 配置\n\n在 tsconfig.json 中配置 JSX 支持：\n\n\n\n配置说明：\n- jsx: \"react-jsx\" - 使用新的 JSX 转换方式（React 17+ 引入）\n- jsxImportSource: \"@wsxjs/wsx-core\" - 指定 JSX 运行时来源为 WSXJS\n\n 2. 类型引用配置\n\n为了获得完整的类型支持，需要在 compilerOptions.types 中添加类型包：\n\n\n\n配置说明：\n- types: \"@wsxjs/wsx-core\" - 显式引用 WSXJS 的类型定义\n- TypeScript 会自动加载 @wsxjs/wsx-core/types/index.d.ts\n- 这确保了 JSX 全局类型和组件类型正确加载\n\n 3. 测试库类型（可选）\n"
    },
    {
      "id": "guide/QUICK_START",
      "title": "QUICK_START",
      "category": "guide",
      "route": "/docs/guide/QUICK_START",
      "content": "WSXJS 快速开始指南\n\n 安装\n\n\n\n 配置\n\n 1. TypeScript 配置\n\n推荐方式：使用 @wsxjs/wsx-tsconfig 包（包含所有必需的配置）：\n\n\n\n手动配置（如果不使用 @wsxjs/wsx-tsconfig）：\n\n\n\n> ⚠️ 重要：如果使用 @state 装饰器，必须配置：\n> - experimentalDecorators: true - 启用装饰器语法\n> - useDefineForClassFields: false - 确保装饰器与类属性兼容\n> \n> 同时，必须在 vite.config.ts 中配置 @wsxjs/wsx-vite-plugin，该插件包含处理 @state 装饰器的 Babel 插件。\n\n> 💡 提示：查看 TypeScript 配置指南TYPESCRIPTSETUP.md 了解完整的配置说明、最佳实践和常见问题解决方案。\n\n 2. Vite 配置\n\n在 vite.config.ts 中添加：\n\n\n\n> ⚠️ 重要：@wsxjs/wsx-vite-plugin 是使用 @state 装饰器的必需配置。该插件包含 B"
    },
    {
      "id": "guide/PUBLISH_GUIDE",
      "title": "PUBLISH_GUIDE",
      "category": "guide",
      "route": "/docs/guide/PUBLISH_GUIDE",
      "content": "WSXJS 发布指南\n\n本指南说明如何使用 Turbo 和 Changesets 发布 WSXJS 的所有包。\n\n> 最佳实践: 本发布流程遵循开源 npm 包发布的最佳实践，包括安全性检查、dry-run 测试、版本验证等。\n\n 前置要求\n\n1. 安装 Turbo（已包含在 devDependencies 中）\n   \n\n2. 确保已登录 NPM\n   \n\n3. 确保在 main 分支且所有更改已提交\n   \n\n 发布流程\n\n 方法 1: 使用自动化发布脚本（推荐）\n\n\n\n这个脚本会自动执行以下步骤：\n\n 阶段 1: 版本管理（可选）\n\n1. ✅ 检查 NPM 认证 - 验证登录状态和 registry 配置\n2. ✅ 检查 Git 状态 - 验证分支、未提交更改、未推送提交\n3. ✅ 检查远程更新 - 自动拉取远程最新代码（推荐）\n4. ✅ 询问版本更新 - 是否要更新版本号\n5. ✅ 创建 Changeset - 如果没有 changeset，自动创建\n6. ✅ 应用版本更新 - 使用 changeset version 更新所有包版本\n7. ✅ 重新构建 - 版本更新后重新构建"
    },
    {
      "id": "guide/LIGHT_COMPONENT_GUIDE",
      "title": "LIGHT_COMPONENT_GUIDE",
      "category": "guide",
      "route": "/docs/guide/LIGHT_COMPONENT_GUIDE",
      "content": "LightComponent 使用指南\n\n 概述\n\nLightComponent 是 WSXJS 提供的轻量级自定义元素基类，专为需要与第三方库集成或使用 Light DOM 的场景设计。它直接继承 HTMLElement，不使用 Shadow DOM，同时提供了完整的响应式状态管理和 JSX 支持。\n\n 为什么使用 LightComponent？\n\n 适用场景\n\n1. 第三方库集成\n   - 需要与 EditorJS、Chart.js 等库集成\n   - 库需要直接访问 DOM 元素\n   - 库使用 document.querySelector 查找元素\n\n2. 路由和布局组件\n   - 容器组件需要全局 DOM 访问\n   - 需要事件冒泡到文档级别\n   - 需要与外部样式系统集成\n\n3. 简单组件\n   - 不需要样式隔离的简单组件\n   - 需要更轻量级的实现\n\n 不适用场景\n\n- 需要样式隔离的 UI 组件（使用 WebComponent）\n\n 快速开始\n\n 基础用法\n\n方式 1: 自动 CSS 注入（推荐）\n\n如果组件文件 MyComponent.wsx 存在对应的 M"
    },
    {
      "id": "guide/JSX_SUPPORT",
      "title": "JSX_SUPPORT",
      "category": "guide",
      "route": "/docs/guide/JSX_SUPPORT",
      "content": "WSXJS JSX 支持文档\n\n 概述\n\nWSXJS 提供了完整的 JSX 支持，无需依赖 React 或其他框架。通过框架级的配置，任何使用 WSX 的项目都能获得开箱即用的 JSX 体验。\n\n 核心特性\n\n- ✅ 零 React 依赖：完全独立的 JSX 实现\n- ✅ 框架级支持：无需消费者项目额外配置\n- ✅ TypeScript 原生支持：符合 TypeScript 标准机制\n- ✅ IDE 友好：完整的类型提示和错误检查\n- ✅ Web Components 集成：完美配合自定义元素\n\n 技术架构\n\n JSX 工厂函数\n\nWSXJS 使用纯原生的 JSX 工厂函数：\n\n\n\n 类型系统\n\n框架提供了完整的 TypeScript 类型支持：\n\n\n\n 配置指南\n\n 1. TypeScript 配置\n\n在项目的 tsconfig.json 中添加以下配置：\n\n\n\n 2. Vite 配置\n\nWSXJS 提供了专门的 Vite 插件：\n\n\n\n 3. ESLint 配置\n\n使用 WSX 专用的 ESLint 插件：\n\n\n\n 使用方法\n\n 基本 JSX 语法\n\n\n\n 事件处理\n\n\n\n 引用回"
    },
    {
      "id": "guide/EXAMPLE_DEVELOPMENT_PLAN",
      "title": "EXAMPLE_DEVELOPMENT_PLAN",
      "category": "guide",
      "route": "/docs/guide/EXAMPLE_DEVELOPMENT_PLAN",
      "content": "WSX 示例组件开发计划\n\n 目标\n通过丰富的示例组件充分展示 WSXJS 的能力，为开发者提供最佳实践参考。\n\n 开发原则\n1. 教学优先 - 每个示例都要清晰展示特定功能\n2. 代码简洁 - 避免过度复杂，聚焦核心概念\n3. 实用性强 - 提供可复用的模式和解决方案\n4. 文档完善 - 每个示例都要有详细注释\n\n 第一阶段：核心功能示例（1-2周）\n\n 1. 生命周期示例 <wsx-lifecycle-demo>\n优先级：高\n- 展示所有生命周期钩子\n- 演示钩子调用顺序\n- 实际应用场景（资源管理、事件监听）\n\n\n 2. 属性观察示例 <wsx-attribute-demo>\n优先级：高\n- observedAttributes 声明\n- 属性变化响应\n- 属性类型转换\n- 默认值处理\n\n\n 3. 事件系统示例 <wsx-event-demo>\n优先级：高\n- 自定义事件派发\n- 事件冒泡控制\n- 跨组件通信\n- 事件委托模式\n\n\n 第二阶段：交互模式示例（2-3周）\n\n 4. 表单集成示例 <wsx-form-demo>\n优先级：高\n- 表单控件集成\n- 验证逻辑\n- Form"
    },
    {
      "id": "guide/DESIGN_PHILOSOPHY",
      "title": "DESIGN_PHILOSOPHY",
      "category": "guide",
      "route": "/docs/guide/DESIGN_PHILOSOPHY",
      "content": "WSXJS 设计理念\n\n 概述\n\nWSXJS 是一个原生优先的 Web Components 框架，致力于提供最接近原生 Web 开发的开发体验，同时保持现代框架的便利性。\n\n 核心设计原则\n\n 1. 原生优先 Native-First\n\nWSXJS 优先使用原生 Web 标准和 API，而不是创建抽象层。\n\n 示例：class vs className\n\n\n\n设计理由：\n- class 是标准 HTML 属性名\n- 避免 JavaScript 保留字冲突\n- 更符合原生 Web 开发习惯\n- 减少学习成本\n\n兼容性：WSX 同时支持 class 和 className，确保 React 开发者的平滑迁移。\n\n 2. 零依赖 Zero Dependencies\n\n框架核心不依赖任何第三方库，确保：\n- 更小的包体积\n- 更快的加载速度\n- 更好的性能\n- 避免依赖冲突\n\n 3. 渐进增强 Progressive Enhancement\n\n\n\n 4. 标准兼容 Standards Compliant\n\n- 完全兼容 Web Components 标准\n- 支持 Shadow DOM\n- "
    }
  ],
  "options": {
    "keys": [
      {
        "name": "title",
        "weight": 0.7
      },
      {
        "name": "content",
        "weight": 0.3
      }
    ],
    "threshold": 0.3,
    "includeScore": true,
    "includeMatches": true
  }
}
