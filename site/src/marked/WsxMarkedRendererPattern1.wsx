/** @jsxImportSource @wsxjs/wsx-core */
/**
 * Pattern 1: Using marked.use({ renderer })
 *
 * This pattern uses marked's built-in renderer system.
 * The renderer returns HTML strings containing WSX custom element tags.
 * Since WSX components are registered as custom elements, they work in HTML strings.
 */

import { LightComponent, autoRegister, createLogger, state } from "@wsxjs/wsx-core";
import { marked } from "marked";
import type { RendererObject, Tokens } from "marked";
import styles from "./WsxMarkedRenderer.css?inline";
import { extractInlineTokens, renderInlineTokens, escapeHtml } from "./marked-utils";
// Import WSX components so they're registered as custom elements
import "./WsxMarkedHeading.wsx";
import "./WsxMarkedCode.wsx";
import "./WsxMarkedBlockquote.wsx";
import "./WsxMarkedParagraph.wsx";
import "./WsxMarkedList.wsx";
import "./WsxMarkedError.wsx";

const logger = createLogger("WsxMarkedRendererPattern1");

/**
 * Pattern 1: Custom Renderer using marked.use()
 *
 * This renderer returns HTML strings with WSX custom element tags.
 * Since WSX components are registered as custom elements, the browser
 * will automatically instantiate them when the HTML is inserted.
 */
@autoRegister({ tagName: "wsx-marked-renderer-pattern1" })
export default class WsxMarkedRendererPattern1 extends LightComponent {
    @state private markdown: string = "";
    private rendererContainer?: HTMLElement;

    constructor() {
        super({
            styles,
            styleName: "wsx-marked-renderer-pattern1",
            lightDOM: true,
        });

        // Register custom renderer with marked
        this.setupCustomRenderer();

        logger.info("WsxMarkedRendererPattern1 initialized");
    }

    static get observedAttributes() {
        return ["markdown"];
    }

    attributeChangedCallback(name: string, oldValue: string, newValue: string) {
        if (name === "markdown") {
            this.markdown = newValue || "";
            this.renderMarkdown();
        }
    }

    render() {
        return (
            <div
                ref={(el: HTMLElement) => {
                    this.rendererContainer = el;
                }}
                class="marked-content"
            />
        );
    }

    protected onConnected() {
        const markdownAttr = this.getAttribute("markdown");
        if (markdownAttr) {
            this.markdown = markdownAttr;
        }
        // Use setTimeout to ensure rendererContainer is set after render()
        setTimeout(() => {
            this.renderMarkdown();
        }, 0);
    }

    /**
     * Setup custom renderer for marked
     * This renderer returns HTML strings containing WSX custom element tags
     */
    private setupCustomRenderer() {
        // renderInlineTokens, extractInlineTokens, and escapeHtml are imported from marked-utils

        const customRenderer: Partial<RendererObject> = {
            // Heading renderer - returns HTML string with WSX custom element
            heading(token: Tokens.Heading) {
                const text = renderInlineTokens(token.tokens);
                return `<wsx-marked-heading level="${token.depth}" text="${escapeHtml(text)}"></wsx-marked-heading>`;
            },

            // Code block renderer
            code(token: Tokens.Code) {
                const code = escapeHtml(token.text);
                const lang = token.lang || "";
                return `<wsx-marked-code code="${code}" language="${lang}"></wsx-marked-code>`;
            },

            // Blockquote renderer - use marked.parser() to handle block-level tokens
            blockquote(token: Tokens.Blockquote) {
                // Use marked.parser() to render the blockquote's tokens
                // This will recursively use our custom renderer for nested elements
                const content = marked.parser(token.tokens);
                return `<wsx-marked-blockquote>${content}</wsx-marked-blockquote>`;
            },

            // Paragraph renderer
            paragraph(token: Tokens.Paragraph) {
                const text = renderInlineTokens(token.tokens);
                // renderInlineTokens returns HTML, so we only need to escape quotes for the attribute value
                // Don't use escapeHtml() which would escape the entire HTML content
                const escapedForAttr = text.replace(/"/g, "&quot;").replace(/'/g, "&#39;");
                return `<wsx-marked-paragraph content="${escapedForAttr}"></wsx-marked-paragraph>`;
            },

            // List renderer - render inline tokens from list item tokens
            list(token: Tokens.List) {
                // List items contain tokens - use extractInlineTokens to handle paragraph tokens
                // This matches Pattern 2's approach but handles paragraph tokens correctly
                const items = token.items.map((item) => {
                    // item.tokens may contain paragraph tokens, so extract inline tokens first
                    const inlineTokens = extractInlineTokens(item.tokens);
                    return renderInlineTokens(inlineTokens);
                });
                // JSON.stringify will escape quotes in the JSON string as \"
                // Use single quotes for the HTML attribute to avoid escaping double quotes
                const jsonStr = JSON.stringify(items);
                // Escape single quotes in the JSON string for the HTML attribute
                const escapedJson = jsonStr.replace(/'/g, "&#39;");
                return `<wsx-marked-list ordered="${token.ordered ? "true" : "false"}" items='${escapedJson}'></wsx-marked-list>`;
            },
        };

        // Register the custom renderer with marked
        marked.use({ renderer: customRenderer as RendererObject });
    }

    /**
     * Render markdown using marked.parse() which uses our custom renderer
     */
    private async renderMarkdown() {
        if (!this.rendererContainer) {
            logger.warn("rendererContainer not set yet, skipping render");
            return;
        }

        if (!this.markdown) {
            logger.warn("markdown is empty, clearing container");
            // Framework-level DOM management for marked renderer Pattern 1
            this.rendererContainer.innerHTML = "";
            return;
        }

        try {
            logger.info("Rendering markdown", { markdownLength: this.markdown.length });

            // marked.parse() will use our custom renderer registered via marked.use()
            // The renderer returns HTML strings with WSX custom element tags
            const htmlResult = marked.parse(this.markdown);
            // marked.parse() may return a Promise in async mode, but in sync mode it returns a string
            const html = typeof htmlResult === "string" ? htmlResult : await htmlResult;

            logger.info("Parsed HTML", {
                htmlLength: html.length,
                htmlPreview: html.substring(0, 100),
            });

            // Insert the HTML string - browser will automatically instantiate WSX custom elements
            // Framework-level DOM management for marked renderer Pattern 1
            this.rendererContainer.innerHTML = html;

            logger.info("Markdown rendered using Pattern 1 (marked.use renderer)");
        } catch (error) {
            logger.error("Failed to render markdown", error);
            if (this.rendererContainer) {
                // Framework-level error rendering for marked renderer
                this.rendererContainer.innerHTML = `<wsx-marked-error message="Error: ${String(error)}"></wsx-marked-error>`;
            }
        }
    }
}
