/** @jsxImportSource @wsxjs/wsx-core */
/**
 * Pattern 2: Using marked.lexer() + Manual WSX JSX Rendering
 *
 * This pattern uses marked.lexer() to get tokens, then manually converts
 * them to WSX JSX elements. This allows us to return actual JSX elements
 * instead of HTML strings.
 */

import { LightComponent, autoRegister, createLogger, state } from "@wsxjs/wsx-core";
import { marked } from "marked";
import type { Tokens } from "marked";
import styles from "./WsxMarkedRenderer.css?inline";
import { renderInlineTokens } from "./marked-utils";
// Import WSX components
import "./WsxMarkedHeading.wsx";
import "./WsxMarkedCode.wsx";
import "./WsxMarkedBlockquote.wsx";
import "./WsxMarkedParagraph.wsx";
import "./WsxMarkedList.wsx";
import "./WsxMarkedError.wsx";

const logger = createLogger("WsxMarkedRenderer");

/**
 * 主 Renderer 组件
 */
@autoRegister({ tagName: "wsx-marked-renderer-pattern2" })
export default class WsxMarkedRenderer extends LightComponent {
    // Pattern 2: Token-based rendering with WSX JSX
    @state private markdown: string = "";

    constructor() {
        super({
            styles,
            styleName: "wsx-marked-renderer",
            lightDOM: true,
        });
        logger.info("WsxMarkedRenderer initialized");
    }

    static get observedAttributes() {
        return ["markdown"];
    }

    attributeChangedCallback(name: string, oldValue: string, newValue: string) {
        if (name === "markdown") {
            this.markdown = newValue || "";
            this.rerender();
        }
    }

    render() {
        if (!this.markdown) {
            return <div class="marked-content"></div>;
        }

        try {
            // 使用 marked.lexer 获取 tokens，然后用 WSX JSX 渲染
            const tokens = marked.lexer(this.markdown);
            return <div class="marked-content">{this.renderTokens(tokens)}</div>;
        } catch (error) {
            logger.error("Failed to render markdown", error);
            return (
                <div class="marked-content">
                    <wsx-marked-error message={`Error: ${error}`} />
                </div>
            );
        }
    }

    protected onConnected() {
        // 从属性获取初始值
        const markdownAttr = this.getAttribute("markdown");
        if (markdownAttr) {
            this.markdown = markdownAttr;
        }
    }

    /**
     * 将 marked tokens 转换为 WSX JSX 元素
     */
    private renderTokens(tokens: Tokens.Generic[]): (HTMLElement | null)[] {
        return tokens
            .map((token) => this.renderToken(token))
            .filter((el): el is HTMLElement => el !== null);
    }

    /**
     * 渲染单个 token 为 WSX JSX 元素
     */
    private renderToken(token: Tokens.Generic): HTMLElement | null {
        switch (token.type) {
            case "heading": {
                const headingToken = token as Tokens.Heading;
                return (
                    <wsx-marked-heading
                        level={headingToken.depth.toString()}
                        text={renderInlineTokens(headingToken.tokens)}
                    />
                );
            }

            case "code": {
                const codeToken = token as Tokens.Code;
                return <wsx-marked-code code={codeToken.text} language={codeToken.lang || ""} />;
            }

            case "blockquote": {
                const blockquoteToken = token as Tokens.Blockquote;
                return (
                    <wsx-marked-blockquote>
                        {this.renderTokens(blockquoteToken.tokens)}
                    </wsx-marked-blockquote>
                );
            }

            case "paragraph": {
                const paraToken = token as Tokens.Paragraph;
                return <wsx-marked-paragraph content={renderInlineTokens(paraToken.tokens)} />;
            }

            case "list": {
                const listToken = token as Tokens.List;
                const items = listToken.items.map((item) => renderInlineTokens(item.tokens));
                return (
                    <wsx-marked-list
                        ordered={listToken.ordered ? "true" : "false"}
                        items={JSON.stringify(items)}
                    />
                );
            }

            case "html": {
                const htmlToken = token as Tokens.HTML;
                return <div>{htmlToken.text}</div>;
            }

            case "hr": {
                return <hr />;
            }

            case "space": {
                // 忽略空格 token
                return null;
            }

            default: {
                // 对于其他类型，使用默认渲染
                const renderer = new marked.Renderer();
                const renderMethod = (
                    renderer as unknown as Record<string, (token: unknown) => string>
                )[token.type];
                const html = renderMethod?.(token) || "";
                if (html) {
                    return <div>{html}</div>;
                }
                return null;
            }
        }
    }
}
