/** @jsxImportSource @wsxjs/wsx-core */
/**
 * Stats Section - å±•ç¤º WSXJS çš„ç»Ÿè®¡æ•°æ®
 * åŒ…æ‹¬ npm downloads, GitHub stars ç­‰
 */
import { LightComponent, autoRegister, state } from "@wsxjs/wsx-core";
import styles from "./StatsSection.css?inline";

@autoRegister({ tagName: "stats-section" })
export class StatsSection extends LightComponent {
    @state private downloads: string = "...";
    @state private stars: string = "...";
    @state private loading: boolean = true;

    constructor() {
        super({ styles });
    }

    protected onConnected(): void {
        this.loadStats();
    }

    render() {
        return (
            <section class="stats-section">
                <div class="container">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-icon">ğŸ“¦</div>
                            <span class="stat-number">{this.downloads}</span>
                            <span class="stat-label">npm downloads/week</span>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon">â­</div>
                            <span class="stat-number">{this.stars}</span>
                            <span class="stat-label">GitHub stars</span>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon">ğŸ“</div>
                            <span class="stat-number">0 KB</span>
                            <span class="stat-label">Runtime size</span>
                        </div>
                    </div>
                </div>
            </section>
        );
    }

    private async loadStats(): Promise<void> {
        try {
            // ä» API æˆ–é™æ€æ•°æ®åŠ è½½
            this.downloads = await this.getNpmDownloads();
            this.stars = await this.getGitHubStars();
        } catch (error) {
            // AbortError æ˜¯é¢„æœŸçš„è¶…æ—¶ï¼Œä¸éœ€è¦æ‰“å°é”™è¯¯æ—¥å¿—
            // getNpmDownloads å’Œ getGitHubStars å†…éƒ¨å·²ç»å¤„ç†äº†é™çº§é€»è¾‘
            if (!this.isAbortError(error)) {
                console.error("Failed to load stats:", error);
            }
            // å¦‚æœå†…éƒ¨æ–¹æ³•éƒ½å¤±è´¥äº†ï¼Œè®¾ç½®é»˜è®¤å€¼
            if (this.downloads === "...") {
                this.downloads = "N/A";
            }
            if (this.stars === "...") {
                this.stars = "N/A";
            }
        } finally {
            this.loading = false;
        }
    }

    /**
     * è·å– API ç«¯ç‚¹ URL
     * å¼€å‘ç¯å¢ƒä½¿ç”¨ Vite ä»£ç†ï¼Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨å…¬å…± API æˆ–å¤‡ç”¨æ–¹æ¡ˆ
     */
    private getApiUrl(path: string, isDev?: boolean): string {
        // æ£€æµ‹å¼€å‘ç¯å¢ƒï¼šä¼˜å…ˆä½¿ç”¨ Vite çš„ import.meta.envï¼Œå¦åˆ™ä½¿ç”¨ process.env
        const isDevelopment =
            isDev ??
            (typeof import.meta !== "undefined" &&
                (import.meta as { env?: { DEV?: boolean } }).env?.DEV) ??
            process.env.NODE_ENV === "development";

        if (isDevelopment) {
            // å¼€å‘ç¯å¢ƒï¼šä½¿ç”¨ Vite ä»£ç†
            if (path.startsWith("https://api.github.com")) {
                return `/api/github${path.replace("https://api.github.com", "")}`;
            }
            if (path.startsWith("https://api.npmjs.org")) {
                return `/api/npm${path.replace("https://api.npmjs.org", "")}`;
            }
        }
        // ç”Ÿäº§ç¯å¢ƒï¼šç›´æ¥ä½¿ç”¨åŸå§‹ URLï¼ˆGitHub API åœ¨ç”Ÿäº§ç¯å¢ƒå¯èƒ½ä»ç„¶æœ‰ CORS é—®é¢˜ï¼‰
        // æ›´å¥½çš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨ shields.io æˆ–æ„å»ºæ—¶è·å–æ•°æ®
        return path;
    }

    /**
     * åˆ›å»ºå¸¦è¶…æ—¶çš„ AbortSignalï¼ˆå…¼å®¹æ€§æ›´å¥½çš„å®ç°ï¼‰
     */
    private createTimeoutSignal(timeoutMs: number): AbortSignal {
        const controller = new AbortController();
        setTimeout(() => controller.abort(), timeoutMs);
        return controller.signal;
    }

    /**
     * æ£€æŸ¥é”™è¯¯æ˜¯å¦ä¸º AbortErrorï¼ˆè¶…æ—¶é”™è¯¯ï¼‰
     * å…¼å®¹ DOMException å’Œ Error ä¸¤ç§ç±»å‹ï¼ŒåŒæ—¶æ£€æŸ¥ name å’Œ message
     */
    private isAbortError(error: unknown): boolean {
        if (!error) return false;
        // æ£€æŸ¥ Error æˆ– DOMException çš„ name å±æ€§
        if (error instanceof Error || error instanceof DOMException) {
            if (error.name === "AbortError") return true;
            // ä¹Ÿæ£€æŸ¥é”™è¯¯æ¶ˆæ¯ä¸­æ˜¯å¦åŒ…å« "abort"ï¼ˆæŸäº›æµè§ˆå™¨å¯èƒ½ name ä¸åŒä½† message åŒ…å« abortï¼‰
            if (error.message && /abort/i.test(error.message)) return true;
        }
        // æ£€æŸ¥æ˜¯å¦ä¸ºåŒ…å« "abort" çš„é”™è¯¯å¯¹è±¡
        if (typeof error === "object" && "name" in error) {
            const name = (error as { name?: string }).name;
            if (name === "AbortError") return true;
            // æ£€æŸ¥ message å±æ€§
            if ("message" in error) {
                const message = (error as { message?: string }).message;
                if (message && /abort/i.test(message)) return true;
            }
        }
        return false;
    }

    private async getNpmDownloads(): Promise<string> {
        try {
            // æ–¹æ¡ˆ 1: ä½¿ç”¨ npm APIï¼ˆå¼€å‘ç¯å¢ƒé€šè¿‡ä»£ç†ï¼Œç”Ÿäº§ç¯å¢ƒç›´æ¥è°ƒç”¨ï¼‰
            const apiUrl = this.getApiUrl(
                "https://api.npmjs.org/downloads/range/last-week/@wsxjs/wsx-core"
            );

            const response = await fetch(apiUrl, {
                // æ·»åŠ è¶…æ—¶æ§åˆ¶ï¼ˆ5ç§’ï¼‰
                signal: this.createTimeoutSignal(5000),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            // è®¡ç®—æ€»ä¸‹è½½é‡
            const totalDownloads =
                data.downloads?.reduce(
                    (sum: number, day: { downloads: number }) => sum + day.downloads,
                    0
                ) || 0;

            // æ ¼å¼åŒ–æ•°å­—
            if (totalDownloads >= 1000) {
                return `${(totalDownloads / 1000).toFixed(1)}k`;
            }
            return totalDownloads.toString();
        } catch (error) {
            // AbortError æ˜¯é¢„æœŸçš„è¶…æ—¶ï¼Œé™é»˜å¤„ç†ï¼Œç›´æ¥é™çº§
            if (this.isAbortError(error)) {
                // é™é»˜å¤„ç†è¶…æ—¶ï¼Œç›´æ¥ä½¿ç”¨é™çº§æ–¹æ¡ˆ
                return await this.getNpmDownloadsFallback();
            }
            // å…¶ä»–é”™è¯¯æ‰è®°å½•æ—¥å¿—
            console.error("Failed to fetch npm downloads:", error);
            // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ shields.io APIï¼ˆæ—  CORS é—®é¢˜ï¼‰
            return await this.getNpmDownloadsFallback();
        }
    }

    /**
     * npm ä¸‹è½½é‡çš„é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ shields.io API
     */
    private async getNpmDownloadsFallback(): Promise<string> {
        try {
            // shields.io æä¾›æ—  CORS é—®é¢˜çš„ API
            const response = await fetch("https://img.shields.io/npm/dw/@wsxjs/wsx-core.json", {
                signal: this.createTimeoutSignal(5000), // å¢åŠ è¶…æ—¶æ—¶é—´åˆ° 5 ç§’
            });
            if (response.ok) {
                const data = await response.json();
                // shields.io è¿”å›æ ¼å¼: { value: "1.2k/week" }
                return data.value?.replace("/week", "") || "N/A";
            }
        } catch (error) {
            // AbortError æ˜¯é¢„æœŸçš„è¶…æ—¶ï¼Œé™é»˜å¤„ç†
            if (!this.isAbortError(error)) {
                console.error("Failed to fetch npm downloads from shields.io:", error);
            }
            // è¶…æ—¶æˆ–å…¶ä»–é”™è¯¯éƒ½è¿”å› "N/A"
        }
        return "N/A";
    }

    private async getGitHubStars(): Promise<string> {
        try {
            // æ–¹æ¡ˆ 1: ä½¿ç”¨ GitHub APIï¼ˆå¼€å‘ç¯å¢ƒé€šè¿‡ä»£ç†ï¼‰
            const apiUrl = this.getApiUrl("https://api.github.com/repos/wsxjs/wsxjs");

            const response = await fetch(apiUrl, {
                // æ·»åŠ è¶…æ—¶æ§åˆ¶ï¼ˆ5ç§’ï¼‰
                signal: this.createTimeoutSignal(5000),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const stars = data.stargazers_count || 0;

            // æ ¼å¼åŒ–æ•°å­—
            if (stars >= 1000) {
                return `${(stars / 1000).toFixed(1)}k`;
            }
            return stars.toString();
        } catch (error) {
            // AbortError æ˜¯é¢„æœŸçš„è¶…æ—¶ï¼Œé™é»˜å¤„ç†ï¼Œç›´æ¥é™çº§
            if (this.isAbortError(error)) {
                // é™é»˜å¤„ç†è¶…æ—¶ï¼Œç›´æ¥ä½¿ç”¨é™çº§æ–¹æ¡ˆ
                return await this.getGitHubStarsFallback();
            }
            // å…¶ä»–é”™è¯¯æ‰è®°å½•æ—¥å¿—
            console.error("Failed to fetch GitHub stars:", error);
            // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ shields.io APIï¼ˆæ—  CORS é—®é¢˜ï¼‰
            return await this.getGitHubStarsFallback();
        }
    }

    /**
     * GitHub stars çš„é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ shields.io API
     */
    private async getGitHubStarsFallback(): Promise<string> {
        try {
            // shields.io æä¾›æ—  CORS é—®é¢˜çš„ API
            const response = await fetch("https://img.shields.io/github/stars/wsxjs/wsxjs.json", {
                signal: this.createTimeoutSignal(5000), // å¢åŠ è¶…æ—¶æ—¶é—´åˆ° 5 ç§’
            });
            if (response.ok) {
                const data = await response.json();
                // shields.io è¿”å›æ ¼å¼: { value: "500" }
                const stars = parseInt(data.value || "0", 10);
                if (stars >= 1000) {
                    return `${(stars / 1000).toFixed(1)}k`;
                }
                return stars.toString();
            }
        } catch (error) {
            // AbortError æ˜¯é¢„æœŸçš„è¶…æ—¶ï¼Œé™é»˜å¤„ç†
            if (!this.isAbortError(error)) {
                console.error("Failed to fetch GitHub stars from shields.io:", error);
            }
            // è¶…æ—¶æˆ–å…¶ä»–é”™è¯¯éƒ½è¿”å› "N/A"
        }
        return "N/A";
    }
}
