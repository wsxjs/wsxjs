/** @jsxImportSource @wsxjs/wsx-core */
/**
 * Stats Section - å±•ç¤º WSXJS çš„ç»Ÿè®¡æ•°æ®
 * åŒ…æ‹¬ npm downloads, GitHub stars ç­‰
 */
import { LightComponent, autoRegister, state } from "@wsxjs/wsx-core";
import styles from "./StatsSection.css?inline";

@autoRegister({ tagName: "stats-section" })
export class StatsSection extends LightComponent {
    @state private downloads: string = "...";
    @state private stars: string = "...";
    @state private loading: boolean = true;

    constructor() {
        super({ styles });
    }

    protected onConnected(): void {
        super.onConnected?.();
        this.loadStats();
    }

    render() {
        return (
            <section class="stats-section">
                <div class="container">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-icon">ğŸ“¦</div>
                            <span class="stat-number">{this.downloads}</span>
                            <span class="stat-label">npm downloads/week</span>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon">â­</div>
                            <span class="stat-number">{this.stars}</span>
                            <span class="stat-label">GitHub stars</span>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon">ğŸ“</div>
                            <span class="stat-number">0 KB</span>
                            <span class="stat-label">Runtime size</span>
                        </div>
                    </div>
                </div>
            </section>
        );
    }

    private async loadStats(): Promise<void> {
        try {
            // ä» API æˆ–é™æ€æ•°æ®åŠ è½½
            this.downloads = await this.getNpmDownloads();
            this.stars = await this.getGitHubStars();
        } catch {
            // AbortError æ˜¯é¢„æœŸçš„è¶…æ—¶ï¼Œä¸éœ€è¦æ‰“å°é”™è¯¯æ—¥å¿—
            // å¦‚æœå†…éƒ¨æ–¹æ³•éƒ½å¤±è´¥äº†ï¼Œè®¾ç½®é»˜è®¤å€¼
            if (this.downloads === "...") {
                this.downloads = "N/A";
            }
            if (this.stars === "...") {
                this.stars = "N/A";
            }
        } finally {
            this.loading = false;
        }
    }

    /**
     * ä» localStorage è·å–ç¼“å­˜çš„æ•°æ®
     */
    private getCachedData(key: string): { value: string; timestamp: number } | null {
        try {
            const cached = localStorage.getItem(`stats_${key}`);
            if (cached) {
                return JSON.parse(cached);
            }
        } catch {
            // å¿½ç•¥è§£æé”™è¯¯
        }
        return null;
    }

    /**
     * å°†æ•°æ®ç¼“å­˜åˆ° localStorageï¼ˆç¼“å­˜ 1 å°æ—¶ï¼‰
     */
    private setCachedData(key: string, value: string): void {
        try {
            const data = {
                value,
                timestamp: Date.now(),
            };
            localStorage.setItem(`stats_${key}`, JSON.stringify(data));
        } catch {
            // å¿½ç•¥å­˜å‚¨é”™è¯¯ï¼ˆå¯èƒ½æ˜¯éšç§æ¨¡å¼ï¼‰
        }
    }

    /**
     * æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ1 å°æ—¶å†…æœ‰æ•ˆï¼‰
     */
    private isCacheValid(cached: { value: string; timestamp: number } | null): boolean {
        if (!cached) return false;
        const CACHE_DURATION = 60 * 60 * 1000; // 1 å°æ—¶
        return Date.now() - cached.timestamp < CACHE_DURATION;
    }

    /**
     * åˆ›å»ºå¸¦è¶…æ—¶çš„ AbortSignalï¼ˆå…¼å®¹æ€§æ›´å¥½çš„å®ç°ï¼‰
     */
    private createTimeoutSignal(timeoutMs: number): AbortSignal {
        const controller = new AbortController();
        setTimeout(() => controller.abort(), timeoutMs);
        return controller.signal;
    }

    /**
     * æ£€æŸ¥é”™è¯¯æ˜¯å¦ä¸º AbortErrorï¼ˆè¶…æ—¶é”™è¯¯ï¼‰
     * å…¼å®¹ DOMException å’Œ Error ä¸¤ç§ç±»å‹ï¼ŒåŒæ—¶æ£€æŸ¥ name å’Œ message
     */
    private isAbortError(error: unknown): boolean {
        if (!error) return false;
        // æ£€æŸ¥ Error æˆ– DOMException çš„ name å±æ€§
        if (error instanceof Error || error instanceof DOMException) {
            if (error.name === "AbortError") return true;
            // ä¹Ÿæ£€æŸ¥é”™è¯¯æ¶ˆæ¯ä¸­æ˜¯å¦åŒ…å« "abort"ï¼ˆæŸäº›æµè§ˆå™¨å¯èƒ½ name ä¸åŒä½† message åŒ…å« abortï¼‰
            if (error.message && /abort/i.test(error.message)) return true;
        }
        // æ£€æŸ¥æ˜¯å¦ä¸ºåŒ…å« "abort" çš„é”™è¯¯å¯¹è±¡
        if (typeof error === "object" && "name" in error) {
            const name = (error as { name?: string }).name;
            if (name === "AbortError") return true;
            // æ£€æŸ¥ message å±æ€§
            if ("message" in error) {
                const message = (error as { message?: string }).message;
                if (message && /abort/i.test(message)) return true;
            }
        }
        return false;
    }

    private async getNpmDownloads(): Promise<string> {
        // æ£€æŸ¥ç¼“å­˜
        const cached = this.getCachedData("npm_downloads");
        if (this.isCacheValid(cached)) {
            return cached!.value;
        }

        // ç›´æ¥ä½¿ç”¨ shields.io APIï¼ˆæ—  CORS é—®é¢˜ï¼Œæ— é€Ÿç‡é™åˆ¶ï¼‰
        try {
            const response = await fetch("https://img.shields.io/npm/dw/@wsxjs/wsx-core.json", {
                signal: this.createTimeoutSignal(5000),
            });
            if (response.ok) {
                const data = await response.json();
                // shields.io è¿”å›æ ¼å¼: { value: "1.2k/week" }
                const value = data.value?.replace("/week", "") || "N/A";
                // ç¼“å­˜ç»“æœ
                this.setCachedData("npm_downloads", value);
                return value;
            }
        } catch {
            // å¦‚æœè¯·æ±‚å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜ï¼ˆå³ä½¿è¿‡æœŸï¼‰
            if (cached) {
                return cached.value;
            }
        }
        return "N/A";
    }

    private async getGitHubStars(): Promise<string> {
        // æ£€æŸ¥ç¼“å­˜
        const cached = this.getCachedData("github_stars");
        if (this.isCacheValid(cached)) {
            return cached!.value;
        }

        // ç›´æ¥ä½¿ç”¨ shields.io APIï¼ˆæ—  CORS é—®é¢˜ï¼Œæ— é€Ÿç‡é™åˆ¶ï¼‰
        try {
            const response = await fetch("https://img.shields.io/github/stars/wsxjs/wsxjs.json", {
                signal: this.createTimeoutSignal(5000),
            });
            if (response.ok) {
                const data = await response.json();
                // shields.io è¿”å›æ ¼å¼: { value: "500" }
                const stars = parseInt(data.value || "0", 10);
                let formattedStars: string;
                if (stars >= 1000) {
                    formattedStars = `${(stars / 1000).toFixed(1)}k`;
                } else {
                    formattedStars = stars.toString();
                }
                // ç¼“å­˜ç»“æœ
                this.setCachedData("github_stars", formattedStars);
                return formattedStars;
            }
        } catch {
            // å¦‚æœè¯·æ±‚å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜ï¼ˆå³ä½¿è¿‡æœŸï¼‰
            if (cached) {
                return cached.value;
            }
        }
        return "N/A";
    }
}
