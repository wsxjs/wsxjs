{
    "title": "Marked + WSX 사용자 정의 렌더러 데모",
    "description": "이 데모는 WSX 컴포넌트를 사용하여 marked의 기본 렌더러를 재정의하여 사용자 정의 대화형 Markdown 렌더링을 만드는 방법을 보여줍니다.",
    "sampleMarkdown": "# Marked + WSX에 오신 것을 환영합니다\n\n이것은 사용자 정의 WSX 렌더러와 함께 `marked`를 사용하는 방법의 **데모**입니다.\n\n## 기능\n\n- WSX 컴포넌트를 사용한 사용자 정의 제목 렌더링\n- 구문 강조가 있는 향상된 코드 블록\n- 스타일이 지정된 컴포넌트를 사용한 사용자 정의 인용 블록\n- WSX 컴포넌트를 사용한 대화형 목록\n\n### 코드 예제\n\n```javascript\n// 이것은 코드 블록입니다\nfunction greet(name) {\n    return `Hello, ${name}!`;\n}\n```\n\n> 이것은 사용자 정의 렌더링을 보여주는 인용 블록입니다\n\n### 목록\n\n1. 첫 번째 항목\n2. 두 번째 항목\n3. 세 번째 항목\n\n- 정렬되지 않은 항목\n- 다른 항목\n\n### 링크 및 이미지\n\n자세한 내용은 [WSXJS](https://wsxjs.dev)를 확인하세요.\n\n---\n\n**굵은 텍스트**와 *기울임꼴 텍스트*도 지원됩니다.",
    "input": {
        "title": "Markdown 입력",
        "placeholder": "여기에 Markdown을 입력하세요...",
        "loadSample": "샘플 로드",
        "clear": "지우기"
    },
    "output": {
        "title": "렌더링된 출력",
        "pattern1": {
            "label": "패턴 1",
            "title": "패턴 1:",
            "description": "marked.use({ renderer }) 사용 - 렌더러는 WSX 사용자 정의 요소 태그가 있는 HTML 문자열을 반환합니다"
        },
        "pattern2": {
            "label": "패턴 2",
            "title": "패턴 2:",
            "description": "marked.lexer() + 수동 WSX JSX 렌더링 사용 - 실제 JSX 요소를 반환합니다"
        }
    },
    "explanation": {
        "title": "작동 방식",
        "pattern1": {
            "title": "패턴 1: marked.use({ renderer })",
            "description": "WSX 사용자 정의 요소 태그를 포함하는 HTML 문자열을 반환하는 사용자 정의 렌더러 개체를 만듭니다. WSX 컴포넌트가 사용자 정의 요소로 등록되어 있으므로 HTML로 삽입될 때 작동합니다.",
            "code": "const renderer = {\n  heading(token) {\n    return `<wsx-marked-heading level=\"${token.depth}\" text=\"...\"></wsx-marked-heading>`;\n  }\n};\n\nmarked.use({ renderer });\nconst html = marked.parse(markdown);\nelement.innerHTML = html; // 브라우저가 WSX 컴포넌트를 자동으로 인스턴스화",
            "pros": "marked의 내장 시스템 사용, 간단함",
            "cons": "HTML 문자열 반환, JSX 요소 아님"
        },
        "pattern2": {
            "title": "패턴 2: marked.lexer() + WSX JSX",
            "description": "marked.lexer()를 사용하여 토큰을 가져온 다음 수동으로 WSX JSX 요소로 변환합니다. 이를 통해 HTML 문자열 대신 실제 JSX 요소를 반환할 수 있습니다.",
            "code": "const tokens = marked.lexer(markdown);\n\nrender() {\n  return (\n    <div>\n      {tokens.map(token => this.renderToken(token))}\n    </div>\n  );\n}\n\nrenderToken(token) {\n  return <wsx-marked-heading level={token.depth} text={token.text} />;\n}",
            "pros": "실제 JSX 요소 반환, 완전히 타입 안전",
            "cons": "더 많은 수동 작업, 모든 토큰 유형을 처리해야 함"
        },
        "components": {
            "title": "WSX 컴포넌트",
            "description": "두 패턴 모두 동일한 WSX Web Components를 사용합니다. 컴포넌트가 사용자 정의 요소로 등록되어 있으므로 HTML 문자열(패턴 1)과 JSX(패턴 2) 모두에서 작동합니다.",
            "code": "@autoRegister({ tagName: 'wsx-marked-heading' })\nclass WsxMarkedHeading extends LightComponent {\n  render() {\n    return <h{this.level}>{this.text}</h{this.level}>;\n  }\n}"
        },
        "pros": "장점:",
        "cons": "단점:"
    },
    "benefits": {
        "title": "WSX 사용자 정의 렌더러의 이점",
        "typeSafety": {
            "label": "타입 안전성:",
            "description": "렌더러 메서드에 대한 완전한 TypeScript 지원"
        },
        "reusability": {
            "label": "컴포넌트 재사용성:",
            "description": "다른 렌더러 메서드에서 WSX 컴포넌트 재사용"
        },
        "interactivity": {
            "label": "대화형:",
            "description": "렌더링된 요소에 이벤트 핸들러 및 반응형 상태 추가"
        },
        "styleIsolation": {
            "label": "스타일 격리:",
            "description": "Web Components는 자동 스타일 범위 지정을 제공합니다"
        },
        "maintainability": {
            "label": "유지보수성:",
            "description": "문자열 연결 대신 깔끔하고 선언적인 JSX 구문"
        }
    }
}
