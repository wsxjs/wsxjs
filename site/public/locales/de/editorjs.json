{
    "title": "EditorJS + WSXJS Demo",
    "tryEditor": "Editor ausprobieren",
    "saveData": "Daten speichern",
    "loadSampleData": "Beispieldaten laden",
    "explanation": {
        "title": "Warum die EditorJS-Plugin-Entwicklung schwierig ist (und wie WSX es l√∂st)",
        "traditionalWay": "‚ùå Der traditionelle Weg ist schwierig",
        "problems": {
            "domManipulation": {
                "title": "1. Manuelle DOM-Manipulation",
                "description": "Sie m√ºssen DOM-Elemente manuell mit ausf√ºhrlichen JavaScript-APIs wie document.createElement, appendChild, setAttribute usw. erstellen, aktualisieren und verwalten. Dies f√ºhrt zu Hunderten von Zeilen Boilerplate-Code.",
                "code": "// Traditioneller Weg - viel Boilerplate\nconst wrapper = document.createElement('div');\nconst input = document.createElement('input');\ninput.setAttribute('type', 'text');\ninput.setAttribute('class', 'alert-input');\ninput.addEventListener('change', handleChange);\nwrapper.appendChild(input);\n// ... 50+ weitere Zeilen f√ºr eine einfache Komponente"
            },
            "typeSafety": {
                "title": "2. Keine Typsicherheit",
                "description": "EditorJS-Tools sind in reinem JavaScript ohne Typpr√ºfung geschrieben. Sie entdecken Fehler zur Laufzeit, nicht w√§hrend der Entwicklung. Eigenschaftsnamen, Datenstrukturen und Methodensignaturen sind alle fehleranf√§llig."
            },
            "stateManagement": {
                "title": "3. Komplexes State-Management",
                "description": "Sie m√ºssen den Komponentenzustand manuell verfolgen, ihn mit EditorJS-Daten synchronisieren, Updates verarbeiten und Konsistenz sicherstellen. Dies erfordert sorgf√§ltige Ereignisbehandlung und State-Synchronisierungslogik, die √ºber Ihren Code verstreut ist."
            },
            "styleIsolation": {
                "title": "4. Style-Isolationsprobleme",
                "description": "Styles lecken zwischen Tools und kollidieren mit EditorJS eigenen Styles. Sie m√ºssen komplexe CSS-Selektoren, BEM-Namenskonventionen oder CSS-in-JS-L√∂sungen verwenden, um Konflikte zu vermeiden."
            },
            "maintainability": {
                "title": "5. Schwer zu warten",
                "description": "Code wird zu einem Durcheinander aus imperativen DOM-Operationen, Event-Listenern und State-Management. Das Hinzuf√ºgen von Funktionen oder das Beheben von Fehlern erfordert das Verst√§ndnis der gesamten Codebasis. Refactoring ist riskant und zeitaufw√§ndig."
            },
            "reusability": {
                "title": "6. Keine Komponenten-Wiederverwendbarkeit",
                "description": "Jedes Tool ist eine monolithische Klasse, in der alles vermischt ist. Sie k√∂nnen UI-Komponenten nicht einfach wiederverwenden, Logik teilen oder komplexe Tools aus einfacheren zusammensetzen."
            }
        },
        "solutions": {
            "title": "‚úÖ Wie WSX es l√∂st",
            "jsxSyntax": {
                "title": "1. Deklarative JSX-Syntax",
                "description": "Schreiben Sie Ihre UI deklarativ mit JSX, genau wie React. Keine manuelle DOM-Manipulation mehr - WSX erledigt alles f√ºr Sie.",
                "code": "// WSX-Weg - sauber und einfach\nrender() {\n    return (\n        <div>\n            <wsx-alert-component\n                type={this.data.type}\n                message={this.data.message}\n                onchange={this.handleChange}\n            />\n        </div>\n    );\n}"
            },
            "typescript": {
                "title": "2. Vollst√§ndige TypeScript-Unterst√ºtzung",
                "description": "Erhalten Sie Typpr√ºfung zur Compile-Zeit, Autovervollst√§ndigung und Refactoring-Unterst√ºtzung. Fangen Sie Fehler ab, bevor sie in die Produktion gelangen. Typsichere Props, Events und Datenstrukturen."
            },
            "reactiveState": {
                "title": "3. Eingebauter reaktiver State",
                "description": "Verwenden Sie den @state-Decorator f√ºr automatische Reaktivit√§t. State-√Ñnderungen l√∂sen automatisch UI-Updates aus. Keine manuelle Synchronisation erforderlich.",
                "code": "@state()\nprivate message = '';\n\n// Aktualisiert automatisch die UI bei √Ñnderung\nthis.message = 'Neuer Wert';"
            },
            "styleIsolation": {
                "title": "4. Automatische Style-Isolation",
                "description": "Web Components mit Shadow DOM bieten automatische Style-Scoping. Ihre Styles sind gekapselt und kollidieren nicht mit EditorJS oder anderen Tools."
            },
            "architecture": {
                "title": "5. Saubere Komponentenarchitektur",
                "description": "Trennung der Anliegen: UI-Komponenten handhaben das Rendering, Tools handhaben die EditorJS-Integration. Einfach zu verstehen, zu testen und zu warten. Refactoring ist sicher und unkompliziert."
            },
            "reusability": {
                "title": "6. Wiederverwendbare Web Components",
                "description": "Erstellen Sie wiederverwendbare Komponenten, die √ºberall funktionieren - in EditorJS, eigenst√§ndigen Seiten oder anderen Frameworks. Komponieren Sie komplexe Tools aus einfachen Komponenten."
            }
        }
    },
    "benefits": {
        "title": "üöÄ Zus√§tzliche Vorteile von WSX",
        "architecture": {
            "label": "Komponentenbasierte Architektur:",
            "description": "Jedes Tool ist eine eigenst√§ndige Web Component"
        },
        "typeSafety": {
            "label": "Typsicherheit:",
            "description": "Vollst√§ndige TypeScript-Unterst√ºtzung mit JSX"
        },
        "declarativeUI": {
            "label": "Deklarative UI:",
            "description": "Erstellen Sie komplexe UIs mit JSX statt manueller DOM-Manipulation"
        },
        "shadowDOM": {
            "label": "Shadow DOM-Isolation:",
            "description": "Styles werden automatisch begrenzt"
        },
        "stateManagement": {
            "label": "Eingebautes State-Management:",
            "description": "Reaktive Updates ohne externe Bibliotheken"
        },
        "developerExperience": {
            "label": "Entwicklererfahrung:",
            "description": "Hot Reload, Debugging-Tools und saubere Codestruktur"
        }
    },
    "info": {
        "customBlockTool": {
            "title": "üì¶ Benutzerdefiniertes Block-Tool",
            "description": "Das WsxAlertTool demonstriert ein benutzerdefiniertes Block-Tool, das mit WSX erstellt wurde. Es bietet Typauswahl, bearbeitbaren Inhalt und ordnungsgem√§√üe Datenpersistenz."
        },
        "inlineTool": {
            "title": "‚úèÔ∏è Inline-Tool",
            "description": "Das WsxHighlightTool zeigt, wie man Inline-Tools mit WSX erstellt. Versuchen Sie, Text auszuw√§hlen und auf die Hervorhebungs-Schaltfl√§che zu klicken oder verwenden Sie"
        },
        "viewSourceCode": "Quellcode auf GitHub ansehen ‚Üí"
    },
    "editor": {
        "placeholder": "Beginnen Sie mit der Eingabe oder klicken Sie auf +, um WSX-Komponenten hinzuzuf√ºgen - Alert, Code, Table und mehr!",
        "defaultData": {
            "welcome": {
                "text": "Willkommen bei EditorJS mit WSX!",
                "description": "Dieser Editor demonstriert, wie WSXJS die EditorJS-Plugin-Entwicklung mit Web Components und JSX verbessern kann.",
                "alertMessage": "Dies ist ein benutzerdefinierter WSX Alert-Block. Versuchen Sie, den Typ zu √§ndern oder die Nachricht zu bearbeiten!"
            }
        },
        "sampleData": {
            "header": {
                "text": "WSX macht die EditorJS-Plugin-Entwicklung besser",
                "description": "Mit WSX k√∂nnen Sie EditorJS-Plugins mit modernen Web Components und JSX-Syntax erstellen. Dies bietet bessere Struktur, Typsicherheit und Entwicklererfahrung.",
                "alertMessage": "Beispieldaten erfolgreich geladen! Dieser Alert-Block wurde mit WSX erstellt."
            },
            "highlight": {
                "description": "Versuchen Sie, diesen Text auszuw√§hlen und das Hervorhebungs-Tool (Cmd+Shift+H) zu verwenden, um das WSX Inline-Tool in Aktion zu sehen!",
                "alertMessage": "Denken Sie daran: WSX-Komponenten sind nur native Web Components mit Superkr√§ften!"
            }
        }
    }
}
