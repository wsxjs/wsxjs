# RFC 0061: 评估焦点管理工具的必要性

## 状态

- **状态**: 完成 (Done)
- **作者**: WSXJS Team
- **创建日期**: 2026-01-24

## 背景

框架目前包含一个专门的焦点管理工具（在早期版本中引入），旨在重新渲染期间保留输入框的焦点和选择状态。在协调算法（reconciliation algorithm）不太成熟且经常导致完整的 DOM 节点替换时，这对防止用户丢失焦点（例如，在输入框中打字时）至关重要。

## 问题

随着协调引擎的近期改进（RFC 0037, RFC 0053, RFC 0059），具体包括：

1.  **细粒度更新**: 仅更新 DOM 中变化的部分。
2.  **稳定的身份标识**: 组件现在拥有稳定的 ID (`_wsxInstanceId`)，防止不必要的卸载。
3.  **严格的协调逻辑**: `updateChildren` 逻辑现在智能地复用现有的 DOM 节点，而不是替换它们。

鉴于这些进步，这种“重手”的焦点管理工具可能已成为多余的开销。如果在更新期间输入元素的 DOM 节点被 *保留* 下来，浏览器会自然地保持焦点和选择状态，无需人工干预。

## 提议：评估与弃用

我们建议评估是否可以移除或简化手动焦点管理逻辑。

### 假设

如果协调工作正常，标准的输入元素（`<input>`, `<textarea>`）在响应式状态更新期间不应通过丢失焦点，因为底层的 DOM `HTMLElement` 实例保持不变。

### 评估步骤

1.  **审计当前用法**: 确定 `captureFocusState` 和 `restoreFocusState` 在 `BaseComponent` 中的调用位置。
2.  **创建压力测试**:
    - 创建一个测试用例，包含一个受控输入框，每次按键都会触发重新渲染。
    - 测量在 *没有* 启用焦点工具的情况下是否会丢失焦点。
    - 测量在 *没有* 焦点工具的情况下光标位置是否会跳变。
3.  **分析边缘情况**:
    - **重新排序**: 如果输入框在列表中移动会发生什么？（例如，对输入框列表进行排序）。
    - **条件渲染**: 如果输入框被条件性地显示/隐藏会发生什么？
    - **Shadow DOM**: Web Components 中的特定行为。

### 移除的成功标准

- [ ] 受控输入框在文本输入期间无需辅助逻辑即可保持焦点。
- [ ] 文本输入期间光标位置得以保留。
- [ ] 移除该工具可减少打包体积（预计 gzipped 后约 1KB）。
- [ ] 移除该工具可降低复杂性（移除 `_pendingFocusState` 和生命周期钩子）。

### 风险缓解

如果完全移除过于激进，我们可能会保留一个“轻量级焦点恢复”机制，仅针对特定的边缘情况（如重新排序）运行，而不是在其每次渲染时捕获状态。

## 需要的决策

通过在功能分支中禁用焦点逻辑并运行回归套件 + 新的手动压力测试来启动评估过程。（已完成，见下文）

## 评估结果 (2026-01-24)

### 测试执行
我们在 `light-component-reconciliation.test.ts` 中添加了压力测试 `Stress Test`，该测试模拟了受控输入框的高频更新。即使在 `LightComponent` 和 `WebComponent` 中禁用了 `captureFocusState` 调用（强制返回 `null`），测试依然**通过**。

### 结论
假设成立：**核心协调引擎 (RFC 0058/0059) 已经足够强大，能够通过复用 DOM 节点来自然保持焦点**。

### 决策
1.  **正式弃用** 手动焦点管理工具。
2.  代码库中的 `captureFocusState` 和 `restoreFocusState` 调用已被注释禁用，建议在后续清理任务中完全删除相关代码。
3.  保留压力测试作为回归测试，防止未来协调逻辑倒退。

## 下一步
- [x] 禁用焦点逻辑进行验证 (已完成)
- [ ] 创建清理任务：删除 `BaseComponent` 中的死代码 (`captureFocusState`, `restoreFocusState`, `_pendingFocusState`)
- [ ] 监控生产环境反馈（如有）
